- Android Framework学习:
    - 1 Java快速入门:
      - 1.1 Java基础知识:
      - 1.2 Java面向对象编程:
      - 1.3 JNI:
      - 1.4 Java高级编程:
    - 2 C++快速入门:
      - 2.1 C++基础知识:
      - 2.2 C++面向对象编程:
      - 2.3 C++高级编程:
      - 2.4 C++设计模式:
    - 3 工具的使用:
      - 3.1 使用AndroidStudio来阅读源码:
      - 3.2 建模工具bouml:
      - 3.3 使用bouml制作时序图:
    - 4 硬件访问服务:
      - 4.1 编写第1个Android应用程序实现按钮和复选框:
      - 4.2 让Android应用程序访问C库:
      - 4.3 Android程序操作LED:
      - 4.4 Android硬件访问框架:
      - 4.5 编写系统代码:
      - 4.6 编写APP代码:
      - 4.7 编写HAL代码:
      - 4.8 Android硬件访问服务使用反射:
    - 5 Android基础知识:
      - 5.1 Android消息处理机制:
      - 5.2 ArrayMap:
    - 6 Android灯光系统:
      - 6.1 总体框架:
      - 6.2 led_class驱动:
      - 6.3 编写HAL_light.c:
      - 6.4 电池灯源码分析:
      - 6.5 通知灯源码分析:
      - 6.6 背光灯源码分析:
    - 7 Android Binder系统:
      - 7.1 C程序示例:
        - 7.1.1 框架分析:
        - 7.1.2 编写程序:
        - 7.1.3 编译查错:
        - 7.1.4 测试与总结:
      - 7.2 驱动情景分析:
        - 7.2.1 数据结构:
        - 7.2.2 打印数据交互过程:
        - 7.2.3 服务注册过程概述:
        - 7.2.4 服务注册过程分析:
        - 7.2.5 服务获取过程:
        - 7.2.6 服务使用过程:
        - 7.2.7 transaction_stack机制_REPLY:
        - 7.2.8 transaction_stack机制_双向服务:
        - 7.2.9 server的多线程实现:
      - 7.3 C++实现:
        - 7.3.1 编写程序:
        - 7.3.2 编写测试:
        - 7.3.3 内部机制_回顾关键点:
        - 7.3.4 内部机制_代理类BpXXX分析:
        - 7.3.5 内部机制_数据传输:
        - 7.3.6 内部机制_添加服务:
        - 7.3.7 编写实现代码:
    - 8 Android输入系统:
      - 8.1 Linux编程知识:
        - 8.1.1 inotify和epoll:
        - 8.1.2 双向通信(scoketpair):
        - 8.1.3 双向通信(socketpair+binder):
      - 8.2 输入系统:
        - 8.2.1 框架:
        - 8.2.2 模拟输入系统驱动:
        - 8.2.3 ReaderDispatcher线程启动分析:
        - 8.2.4 Reader线程使用EventHub读取事件:
        - 8.2.5 Reader线程核心类及配置文件实验:
        - 8.2.6 Reader线程核心类及配置文件分析:
        - 8.2.7 Reader线程简单处理:
        - 8.2.8 Dispatcher线程总体框架:
        - 8.2.9 Dispatcher线程情景分析_Reader线程传递事件:
        - 8.2.10 Dispatcher线程情景分析_dispatch前处理:
        - 8.2.11 实战_使用GlobalKey一键启动程序:
        - 8.2.12 App跟输入系统建立联系InputChannel和Connection:
        - 8.2.13 Dispatcher线程分发dispatch:
        - 8.2.14 APP获得并处理输入事件流程:
        - 8.2.15 补充知识activity_window_decor_view关系_理论:
        - 8.2.16 补充知识activity_window_decor_view关系_实验:
        - 8.2.17 InputStage理论:
        - 8.2.18 InputStage实验_截取输入事件:
        - 8.2.19 多点触摸驱动程序:
        - 8.2.20 多点触摸驱动程序_编写框架:
        - 8.2.21 多点触摸驱动程序_编写框架_实践tiny4412:
        - 8.2.22 多点触摸驱动程序_idc配置文件:
        - 8.2.23 多点触摸程序_Reader线程:
        - 8.2.24 多点触摸驱动程序_InputStage:
    - 9 Android音频系统:
      - 9.1 声音的采集与存储:
      - 9.2 Android音频系统框架简述:
      - 9.3 Linux音频驱动: 
        - 9.3.1 alsa音频驱动框架:
        - 9.3.2 ASoC音频驱动框架:
        - 9.3.3 tiny4412声卡驱动移植_combine:
        - 9.3.4 声卡控制之kcontrol:
        - 9.3.5 DAPM_widget_route_path:
        - 9.3.6 DAPM的kcontrol注册过程:
        - 9.3.7 route_path添加过程分析:
        - 9.3.8 DAPM的情景分析_构造过程:
        - 9.3.9 DAPM的情景分析_使用过程:
        - 9.3.10 tiny4412声卡驱动录音功能调试:
      - 9.4 Android音频:
        - 9.4.1 分析思路:
        - 9.4.2 以例子说明几个重要概念:
        - 9.4.3 所涉及文件形象讲解:
        - 9.4.4 AudioPolicyService启动过程分析:
        - 9.4.5 AudioFlinger启动过程分析:
        - 9.4.6 AudioTrack创建过程:
        - 9.4.7 AudioPolicyManager勘误与回顾:
        - 9.4.8 AudioTrack创建过程_选择output:
        - 9.4.9 AudioTrack创建过程_Track和共享内存:
        - 9.4.10 音频数据的传递:
        - 9.4.11 PlaybackThread处理流程:
      - 9.5 项目实战1_耳麦拔插:
        - 9.5.1 驱动程序上报耳麦拔插事件:
        - 9.5.2 在状态栏显示耳麦图标:
        - 9.5.3 耳麦拔插事件调用流程分析:
        - 9.5.4 切换声音通道流程:
      - 9.6 音频系统HAL分析:
        - 9.6.1 HAL之框架:
        - 9.6.2 HAL之调用流程源码分析:
      - 9.7 音量调节:
        - 9.7.1 音量相关概念:
        - 9.7.2 AudioFlinger层调节音量流程:
        - 9.7.3 音量键和Setting界面调节音量流程:
      - 9.8 项目实战2_多APP同时录音:
        - 9.8.1 使用C++编写录音程序:
        - 9.8.2 录音框架及代码流程:
        - 9.8.3 修改代码支持多APP同时录音:
    - 10 Android显示系统:
      - 10.1 显示系统框架:
        - 10.1.1 framebuffer原理及改进:
        - 10.1.2 初步分析:
      - 10.2 禁用hwc和gpu:
        - 10.2.1 最终的补丁:
        - 10.2.2 去除厂家gralloc_hw模块:
        - 10.2.3 使用软件GL库:
        - 10.2.4 修改gralloc:
      - 10.3 Surface和SurfaceFlinger:
        - 10.3.1 最简单的Surface测试程序:
        - 10.3.2 App与SurfaceFlinger的数据结构:
        - 10.3.3 APP创建SurfaceFlinger客户端(client)的过程:
        - 10.3.4 App申请创建Surface的过程:
        - 10.3.5 App申请(lock)Buffer的过程_框架:
        - 10.3.6 App申请(lock)Buffer的过程_分配buffer:
        - 10.3.7 App申请(lock)Buffer的过程_获取buffer信息:
        - 10.3.8 APP提交(unlockAndPost)Buffer的过程_框架:
        - 10.3.9 APP提交(unlockAndPost)Buffer的过程_消费者创建过程: 
        - 10.3.10 APP提交(unlockAndPost)Buffer的过程_提交过程: 
      - 10.4 vsync机制:
        - 10.4.1 黄油计划_三个方法改进显示系统:
        - 10.4.2 Vsync框架:
        - 10.4.3 初始化代码分析:
        - 10.4.4 surface使用vsync过程代码分析:
        - 10.4.5 surfaceflinger对vsync的处理:
        - 10.4.6 基础知识_Region定义及操作:
        - 10.4.7 rebuildLayerStacks源码分析:
        - 10.4.8 DisplayDevice创建流程分析:
        - 10.4.9 使用opengl进行界面合成流程速览:
      - 10.5 HDMI_HDMI硬件介绍:
        - 10.5.1 HDMI_HDMI硬件介绍:
        - 10.5.2 HDMI_4412的HDMI驱动程序框架:
        - 10.5.3 HDMI_HDMI热拔插检测驱动程序_总述及字符驱动:
        - 10.5.4 HDMI_HDMI热拔插检测驱动程序_switch系统:
        - 10.5.5 HDMI_HDMI热拔插检测驱动程序_HPD引脚的两种功能:
    - 11 Android BLE协议栈:
      - 11.1 生活中的实例_医院的结构: 
      - 11.2 BLE协议各层的形象化理解: 
      - 11.3 BLE协议各层数据格式概述:
      - 11.4 BLE协议抓包演示:  
      - 11.5 BLE协议物理层(PHY): 
      - 11.6 体验开源蓝牙协议栈BTStack: 
      - 11.7 开源蓝牙协议栈BTStack框架分析: 
      - 11.8 开源蓝牙协议栈BTStack框架代码阅读: 
      - 11.9 开源蓝牙协议栈BTStack数据处理: 
      - 11.10 使用BTStack编写蓝牙程序: 
      - 11.11 BLE协议链路层(LL): 
      - 11.12 BLE协议HCI层的硬件接口: 
      - 11.13 BLE协议HCI层的数据格式: 
      - 11.14 BLE协议L2CAP层: 
      - 11.15 BLE协议ATT层:
      - 11.16 BLE协议GATT层:  
      - 11.17 BLE协议GAP层: 
      - 11.18 BLE安全管理概述: 
      - 11.19 地址类型与LL层设备过滤: 
    - 12 Android ALSA声卡:
      - 12.1 裸板之原理和框架:
      - 12.2 裸板之编写程序:
      - 12.3 裸板之编译和测试:
      - 12.4 ALSA驱动框:
      - 12.5 ASoC驱动框架:
      - 12.6 体验声卡:
      - 12.7 分析调用过程:
      - 12.8 从零编写之框架:
      - 12.9 从零编写之参数设置:
      - 12.10 从零编写之数据传:
      - 12.11 从零编写之调试:
      - 12.12 从零编写之添加音量控制:
      - 12.13 从零编写之WM8976:
      - 12.14 移植原厂WM8976驱动:
      - 12.15 修改内核声卡BUG:
      - 12.16 ALSA声卡应用程序:
---
comments: true
title: 构造数据抽象
---
# Building Abstractions with Data(构造数据抽象)

!!! quote

    We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. ...[The mathematician] need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for.<br>
    现在到了数学抽象中最关键的一步：让我们忘记这些符号所表示的对象。……(数学家)不应在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们到底代表着什么东西

    —— Hermann Weyl, The Mathematical Way of Thinking <br>
    —— Hermann Weyl, (思维的数学方式)

We concentrated in [Chapter 1] on computational processes and on the role of procedures in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine procedures to form compound procedures through composition, conditionals, and the use of parameters, and how to abstract procedures by using define. We saw that a procedure can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in procedures. We also saw that higher-order procedures enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming.<br>
我们在[第1章]里关注的是计算过程，以及过程在程序中所扮演的角色。在那里我们还看到了怎样使用基本数据(数)和基本操作(算术运算);怎样通过复合、条件，以及参数的使用将一些过程组合起来，形成复合的过程；怎样通过define做过程抽象。我们也看到，可以将一个过程看作一类计算演化的一个模式。那里还对过程中蕴涵着的某些常见计算模式做了一些分类和推理，并做了一些简单的算法分析。我们也看到了高阶过程，这种机制能够提升语言的威力，因为它将使我们能去操纵通用的计算方法，并能对它们做推理。这些都是程序设计中最基本的东西。

In this chapter we are going to look at more complex data. All the procedures in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining procedures to form compound procedures, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form compound data.<br>
在这一章里，我们将进一步去考查更复杂的数据。第1章里的所有过程，操作的都是简单的数值数据，而对我们希望用计算去处理的许多问题而言，只有这种简单数据还不够。许多程序在设计时就是为了模拟复杂的现象，因此它们就常常需要构造起一些计算对象，这些对象都是由一些部分组成的，以便去模拟真实世界里的那些具有若干侧面的现象。这样，与我
们在第1章里所做的事情(通过将一些过程组合起来形成复合的过程，以这种方式构造起各种抽象)相对应，本章将重点转到各种程序设计语言都包含的另一个关键方面：讨论它们所提供的，将数据对象组合起来，形成复合数据的方式。

Why do we want compound data in a programming language? For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.<br>
为什么在程序设计语言里需要复合数据呢?与我们需要复合过程的原因一样：同样是为了提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。正如定义过程的能力使我们有可能在更高的概念层次上处理计算工作一样，能够构造复合数据的能力，也将使我们得以在比语言提供的基本数据对象更高的概念层次上，处理与数据有关的各种问题。

Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation add-rat that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where add-rat would be implemented by two procedures (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could ``glue together'' a numerator and denominator to form a pair -- a compound data object -- that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit.<br>
现在考虑设计一个系统，它完成有理数的算术。我们可以设想一个运算add-rat,它以两个有理数为参数，产生出它们的和。从基本数据出发，一个有理数可以看作两个整数，一个分子和一个分母。这样，我们就可以设计出一个程序，其中的每个有理数用两个整数表示(一个分子和一个分母),而其中的add-rat用两个过程实现(一个产生和数的分子，另一个产生和数的分母)。然而，这样做下去会非常难受，因为我们必须明确地始终记住哪个分子与哪个分母相互对应。在一个需要执行大量有理数操作的系统里，这种记录工作将会严重地搅乱我们的程序，而这些麻烦又与我们心中真正想做的事情毫无关系。如果能将一个分子和一个分母“粘在一起”,形成一个对偶——一个复合数据对象——事情就会好得多了，因为这样，程序中对有理数的操作就可以按照将它们作为一个概念单位的方式进行了。

The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called data abstraction. We will see how data abstraction makes programs much easier to design, maintain, and modify.<br>
复合数据的使用也使我们能进一步提高程序的模块性。如果我们可以直接在将有理数本身当作对象的方式下操作它们，那么也就可能把处理有理数的那些程序部分，与有理数如何表示的细节(可能是表示为一对整数)隔离开。这种将程序中处理数据对象的表示的部分，与处理数据对象的使用的部分相互隔离的技术非常具有一般性，形成了一种称为数据抽象的强有力的设计方法学。我们将会看到，数据抽象技术能使程序更容易设计、维护和修改。

The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a ``linear combination'' ax + by. We might like to write a procedure that would accept a, b, x, and y as arguments and return the value of ax + by. This presents no difficulty if the arguments are to be numbers, because we can readily define the procedure<br>
复合对象的使用将真正提高程序设计语言的表达能力。考虑形成“线性组合”ax+by,我们可能想到写一个过程，让它接受a、b、x和y作为参数并返回ax+by的值。如果以数值作为参数，这样做没有任何困难，因为我们立刻就能定义出下面的过程：

```
(define (linear-combination a b x y) 
  (+ (* a x) (* b y)))
```

But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form linear combinations whenever addition and multiplication are defined -- for rational numbers, complex numbers, polynomials, or whatever. We could express this as a procedure of the form<br>
但是，如果我们关心的不仅仅是数，假定在写这个过程时，我们希望表述的是基于加和乘形成线性组合的思想，所针对的可以是有理数、复数、多项式或者其他东西，我们可能将其表述为下面形式的过程：

```
(define (linear-combination a b x y)     
  (add (mul a x) (mul b y))) 
```

where `add` and `mul` are not the primitive procedures `+` and `*` but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments `a`, `b`, `x`, and `y`. The key point is that the only thing `linear-combination` should need to know about `a`, `b`, `x`, and `y` is that the procedures `add` and `mul` will perform the appropriate manipulations. From the perspective of the procedure `linear-combination`, it is irrelevant what `a`, `b`, `x`, and `y` are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a procedure such as `linear-combination` to pass its arguments along to `add` and `mul` without having to know their detailed structure.[^1]<br>
其中的`add`和`mul`不是基本过程`+`和`*`,而是某些更复杂的东西，它们能对通过参数`a`、`b`、`x`和`y`送来的任何种类的数据执行适当的操作。在这里最关键的是，`linear-combination`对于`a`、`b`、`x`和`y`需要知道的所有东西，也就是过程add和mul能够执行适当的操作。从过程`linear-combination`的角度看，`a`、`b`、`x`和y究竟是什么，其实根本就没有关系，至于它们是怎样基于更基本的数据表示就更没有关系了。这个例子也说明了，为什么一种程序设计语言能够提供直接操作复合对象的能力是如此的重要，因为如果没有这种能力，我们就没有办法让一个像linear-combination这样的过程将其参数传递给`add`和`mu1`,而不必知道这些参数的具体细节结构。[^1]

We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound procedures, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable abstraction barriers between different parts of a program.<br>
作为本章的开始，我们要实现上面所说的那样一个有理数算术系统，它将成为后面讨论复合数据和数据抽象的一个基础。与复合过程一样，在这里需要考虑的主要问题，也是将抽象作为克服复杂性的一种技术。下面将会看到，数据抽象将如何使我们能在程序的不同部分之间建立起适当的抽象屏障。

We will see that the key to forming compound data is that a programming language should provide some kind of ''glue'' so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special ''data'' operations at all, only procedures. This will further blur the distinction between ''procedure'' and ''data,'' which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of closure -- that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as conventional interfaces for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure.<br>
我们将会看到，形成复合数据的关健就在于，程序设计语言里应该提供了某种“黏合剂”,它们可以用于把一些数据对象组合起来，形成更复杂的数据对象。黏合剂可能有很多不同的种类。确实的，我们还会发现怎样去构造出根本没有任何特定“数据”操作，只是由过程形成的复合数据。这将进一步模糊“过程”和“数据”之间的划分。实际上，在第1章的最后，这一界限已经开始变得不那么清楚了。我们还要探索表示序列和树的一些常规技术。在处理复合数据中的一个关键性思想是闭包的概念——也就是说，用于组合数据对象的黏合剂不但能用于组合基本的数据对象，同样也可以用于复合的数据对象。另一关键思想是，复合数据对象能够成为以混合与匹配的方式组合程序模块的方便界面。我们将通过给出一个利用闭包概念的简单图形语言的方式，阐释有关的思想。

We will then augment the representational power of our language by introducing symbolic expressions -- data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information.<br>
而后我们要引进符号表达式，进一步扩大语言的表述能力。符号表达式的基本部分可以是任意的符号，不一定就是数。我们将探索表示对象集合的各种不同方式，由此可以发现，就像一个给定的数学函数可以通过许多不同的计算过程计算一样，对于一种给定的数据结构，也可以有许多方式将其表示为简单对象的组合，而这种表示的选择，有可能对操作这些数据的计算过程的时间与空间需求造成重大的影响。我们将在符号微分、集合的表示和信息编码的上下文中研究这些思想。

Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement generic operations, which must handle many different types of data. Maintaining modularity in the presence of generic operations requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce data-directed programming as a technique that allows individual data representations to be designed in isolation and then combined additively (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials.<br>
随后我们将转去处理在一个程序的不同部分可能采用不同表示的数据的问题，这就引出了实现通用型操作的需要，这种操作必须能处理许多不同的数据类型。为了维持模块性，通用型操作的出现，将要求比只有简单数据抽象更强大的抽象屏障。特别地，我们将介绍数据导向的程序设计。这是一种技术，它能允许我们孤立地设计每一种数据表示，而后用添加的方式将它们组合进去(也就是说，不需要任何修改)。为了展示这一系统设计方法的威力，在本章的最后，我们将用已经学到的东西实现一个多项式符号算术的程序包，其中多项式的系数可以是整数、有理数、复数，甚至还可以是其他多项式。

[^1]: The ability to directly manipulate procedures provides an analogous increase in the expressive power of a programming language. For example, in section 1.3.1 we introduced the sum procedure, which takes a procedure term as an argument and computes the sum of the values of term over some specified interval. In order to define sum, it is crucial that we be able to speak of a procedure such as term as an entity in its own right, without regard for how term might be expressed with more primitive operations. Indeed, if we did not have the notion of ``a procedure,'' it is doubtful that we would ever even think of the possibility of defining an operation such as sum. Moreover, insofar as performing the summation is concerned, the details of how term may be constructed from more primitive operations are irrelevant.<br>
直接操作过程的能力，也使程序设计语言的表达能力得到类似的提高。例如，在1.3.1节里给出了过程sum,它以过程term作为一个参数，计算出term在某个特定区间上的值之和。为了定义这一sum,必不可少的条件就是能直接去说像term这样的过程，而不必考虑它可能如何通过更基本的操作表达出来。的确，如果没有“过程”这一概念，认为我们有可能定义像sum这样的操作就很值得怀疑了。进一步说，就执行求和而言，term究竟能怎样由更基本的操作构造起来的情况，确实也没必要去关心。

[Chapter 1]: {{ config.extra.homepage_sicp }}/chapter_1/
[第1章]: {{ config.extra.homepage_sicp }}/chapter_1/
[1.3.1]: {{ config.extra.homepage_sicp }}/chapter_1/chapter_1_3/1.3.1
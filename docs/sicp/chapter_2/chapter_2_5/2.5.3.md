---
comments: true
---

# 2.5.3  Example: Symbolic Algebra(实例：符号代数)
The manipulation of symbolic algebraic expressions is a complex process that illustrates many of the hardest problems that occur in the design of large-scale systems. An algebraic expression, in general, can be viewed as a hierarchical structure, a tree of operators applied to operands. We can construct algebraic expressions by starting with a set of primitive objects, such as constants and variables, and combining these by means of algebraic operators, such as addition and multiplication. As in other languages, we form abstractions that enable us to refer to compound objects in simple terms. Typical abstractions in symbolic algebra are ideas such as linear combination, polynomial, rational function, or trigonometric function. We can regard these as compound ''types,'' which are often useful for directing the processing of expressions. For example, we could describe the expression<br />
符号表达式的操作是一种很复杂的计算过程，它能够展示出在设计大型系统时常常会出现的许多困难问题。一般来说，一个代数表达式可以看成一种具有层次结构的东西，它是将运算符作用于一些运算对象而形成的一棵树。我们可以从一集基本对象，例如常量和变量出发，通过各种代数运算符如加法和乘法的组合，构造起各种各样的代数表达式。就像在其他语营里一样，在这里也需要形成各种抽象，使我们能够有简单的方式去引用复合对象。在符号代数中，与典型抽象的有关想法包括线性组合、多项式、有理函数和三角函数等等。可以将这些看作是复合的“类型”,它们在制导对表达式的处理过程方面非常有用。例如，我们可以将表达式：

$$ x^2 \sin (y^2 + 1) + x \cos 2y + \cos(y^3 - 2y^2) $$

as a polynomial in x with coefficients that are trigonometric functions of polynomials in y whose coefficients are integers.<br />
看作一个x的多项式，其参数是y的多项式的三角函数，而y的多项式的系数是整数。

We will not attempt to develop a complete algebraic-manipulation system here. Such systems are exceedingly complex programs, embodying deep algebraic knowledge and elegant algorithms. What we will do is look at a simple but important part of algebraic manipulation: the arithmetic of polynomials. We will illustrate the kinds of decisions the designer of such a system faces, and how to apply the ideas of abstract data and generic operations to help organize this effort.<br />
下面我们将试着开发一个完整的代数演算系统。这类系统都是异乎寻常地复杂的程序，包含着深入的代数知识和美妙的算法。我们将要做的，只是考察代数演算系统中一个简单但却很重要的部分，多项式算术。我们将展示在设计这样一个系统时所面临的各种抉择，以及如何应用抽象数据和通用型操作的思想，以利于组织好这一工作项目。

## Arithmetic on polynomials(多项式算术)
Our first task in designing a system for performing arithmetic on polynomials is to decide just what a polynomial is. Polynomials are normally defined relative to certain variables (the *indeterminates* of the polynomial). For simplicity, we will restrict ourselves to polynomials having just one indeterminate (*univariate polynomials*).[^1] We will define a polynomial to be a sum of terms, each of which is either a coefficient, a power of the indeterminate, or a product of a coefficient and a power of the indeterminate. A coefficient is defined as an algebraic expression that is not dependent upon the indeterminate of the polynomial. For example,<br />
要设计一个执行多项式算术的系统，第一件事情就是确定多项式到底是什么。多项式通常总是针对某些特定的变量(多项式中的未定元)定义的。为了筒单起见，我们把需要考虑的多项式限制到只有一个未定元的情况(单变元多项式)[^1]。下面将多项式定义为项的和式，而每个项或者就是一个系数，或者是未定元的乘方，或者是一个系数与一个未定元乘方的乘积。系数也定义为一个代数表达式，但它不依赖于这个多项式的未定元。例如：

$$ 5x^2 + 3x + 7 $$

is a simple polynomial in ${x}$, and<br />
是 ${x}$ 的一个简单多项式，而

$$ (y^2 + 1)x^3 + (2y)x + 1 $$

is a polynomial in ${x}$ whose coefficients are polynomials in ${y}$.<br />
是 ${x}$ 的一个多项式，而其参数又是 ${y}$ 的多项式。

Already we are skirting some thorny issues. Is the first of these polynomials the same as the polynomial ${5y^2 + 3y + 7}$, or not? A reasonable answer might be ''yes, if we are considering a polynomial purely as a mathematical function, but no, if we are considering a polynomial to be a syntactic form.'' The second polynomial is algebraically equivalent to a polynomial in y whose coefficients are polynomials in x. Should our system recognize this, or not? Furthermore, there are other ways to represent a polynomial -- for example, as a product of factors, or (for a univariate polynomial) as the set of roots, or as a listing of the values of the polynomial at a specified set of points.[^2] We can finesse these questions by deciding that in our algebraic-manipulation system a ''polynomial'' will be a particular syntactic form, not its underlying mathematical meaning.<br />
这样，我们就已经绕过了某些棘手问题。例如，上面的第一个多项式是否与多项式  ${5y^2 + 3y + 7}$ 相同?为什么?合理的回答可以是“是，如果我们将多项式看作一种纯粹的数学函数；但又不是，如果只是将多项式看作一种语法形式"。第二个多项式在代数上等价于一个y的多项式，其系数是x的多项式。我们的系统将应认定这一情况吗，或者不认定?进一步说，表示一个多项式的方式可以有很多种——例如，将其作为因子的乘积，或者(对于单变元多项式)[^2]作为一组根，或者作为多项式在些特定集合里各个点处的值的列表1²'。我们可以使一点手段以避免这些问题。现在我们确定，在这一代数演算系统里，一个“多项式”就是一种特殊的语法形式，而不是在其之下的数学意义。

Now we must consider how to go about doing arithmetic on polynomials. In this simple system, we will consider only addition and multiplication. Moreover, we will insist that two polynomials to be combined must have the same indeterminate.<br />
现在必须进一步去考虑怎样做多项式算术。在这个简单的系统里，我们将仅仅考虑加法和乘法。进一步说，我们还强制性地要求两个参与运算的多项式具有相同的未定元。

We will approach the design of our system by following the familiar discipline of data abstraction. We will represent polynomials using a data structure called a *poly*, which consists of a variable and a collection of terms. We assume that we have selectors `variable` and `term-list` that extract those parts from a poly and a constructor `make-poly` that assembles a poly from a given variable and a term list. A variable will be just a symbol, so we can use the `same-variable?` procedure of section [2.3.2] to compare variables. The following procedures define addition and multiplication of polys:<br />
下面将根据我们已经熟悉的数据抽象的一套方式，开始设计这个系统。多项式将用一种称为`poly`的数据结构表示，它由一个变量和一组项组成。我们假定已有选择函数`variable`和`term-list`,用于从一个多项式中提取相应的部分。还有一个构造函数`make-poly`,从给定变量和项表构造出一个多项式。一个变量也就是一个符号，因此我们可以用[2.3.2]节的`same-variable?`过程做变量的比较。下面过程定义多项式的加法和乘法：

```
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var -- ADD-POLY"
             (list p1 p2))))
(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var -- MUL-POLY"
             (list p1 p2))))
```

To incorporate polynomials into our generic arithmetic system, we need to supply them with type tags. We'll use the tag `polynomial`, and install appropriate operations on tagged polynomials in the operation table. We'll embed all our code in an installation procedure for the polynomial package, similar to the ones in section [2.5.1]:<br />
为了将多项式结合到前面建立起来的通用算术系统里，我们需要为其提供类型标志。这里采用标志`polynomial`,并将适合用于带标志多项式的操作安装到操作表格里。我们将所有代码都嵌入完成多项式包的安装过程中，与在[2.5.1]节里采用的方式类似：

```
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  <procedures same-variable? and variable? from section [2.3.2]>
  ;; representation of terms and term lists
  <procedures adjoin-term ...coeff from text below>

  ;; continued on next page

  (define (add-poly p1 p2) ...)
  <procedures used by add-poly>
  (define (mul-poly p1 p2) ...)
  <procedures used by mul-poly>
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) 
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) 
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done)
```

Polynomial addition is performed termwise. Terms of the same order (i.e., with the same power of the indeterminate) must be combined. This is done by forming a new term of the same order whose coefficient is the sum of the coefficients of the addends. Terms in one addend for which there are no terms of the same order in the other addend are simply accumulated into the sum polynomial being constructed.<br />
多项式加法通过一项项的相加完成，同次的项(即，具有同样未定元幂次的项)必须归并到一起。完成这件事的方式是建立一个同次的新项，其系数是两个项的系数之和。仅仅出现在一个求和多项式中的项就直接累积到正在构造的多项式里。

In order to manipulate term lists, we will assume that we have a constructor `the-empty-termlist` that returns an empty term list and a constructor `adjoin-term` that adjoins a new term to a term list. We will also assume that we have a predicate `empty-termlist?` that tells if a given term list is empty, a selector `first-term` that extracts the highest-order term from a term list, and a selector `rest-terms` that returns all but the highest-order term. To manipulate terms, we will suppose that we have a constructor `make-term` that constructs a term with given order and coefficient, and selectors `order` and `coeff` that return, respectively, the order and the coefficient of the term. These operations allow us to consider both terms and term lists as data abstractions, whose concrete representations we can worry about separately.<br />
为了能完成对于项表的操作，我们假定有一个构造函数`the-empty-termlis`t,它返回一个空的项表，还有一个构造函数`adjoin-term`将一个新项加入一个项表里。我们还假定有一个谓词`empty-termlist?`,可用于检查一个项表是否为空；选择函数`first-term`提取出一个项表中最高次数的项，选择函数`rest-terms`返回除最高次项之外的其他项的表。为了能对项进行各种操作，我们假定已经有一个构造函数`make-term`,它从给定的次数和系数构造出一个项；选择函数`order`和`coeff`分别返回一个项的次数和系数。这些操作使我们可以将项和项表都看成数据抽象，其具体实现就可以另行单独考虑了。

Here is the procedure that constructs the term list for the sum of two polynomials:[^3]<br />
下面是一个过程，它从两个需要求和的多项式构造起一个项表[^3]

```
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
```

The most important point to note here is that we used the generic addition procedure add to `add` together the coefficients of the terms being combined. This has powerful consequences, as we will see below.<br />
在这里需要注意的最重要的地方是，我们采用了通用型的加法过程`add`去求需要归并的项的系数之和。这样做有一个特别有利的后果，下面就会看到。

In order to multiply two term lists, we multiply each term of the first list by all the terms of the other list, repeatedly using `mul-term-by-all-terms`, which multiplies a given term by all terms in a given term list. The resulting term lists (one for each term of the first list) are accumulated into a sum. Multiplying two terms forms a term whose order is the sum of the orders of the factors and whose coefficient is the product of the coefficients of the factors:<br />
为了乘起两个项表，我们用第一个表中的每个项去乘另一表中所有的项，通过反复应用`mul-term-by-all-terms`(这个过程用一个给定的项去乘一个项表里的各个项)完成项表的乘法。这样得到的结果项表(对于第一个表的每个项各有一个表)通过求和积累起来。乘起两个项形成一个新项的方式是求出两个因子的次数之和作为结果项的次数，求出两个因子的系数的乘积作为结果项的系数：

```
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms t1 (rest-terms L))))))
```

This is really all there is to polynomial addition and multiplication. Notice that, since we operate on terms using the generic procedures `add` and `mul`, our polynomial package is automatically able to handle any type of coefficient that is known about by the generic arithmetic package. If we include a coercion mechanism such as one of those discussed in section [2.5.2], then we also are automatically able to handle operations on polynomials of different coefficient types, such as<br />
这些也就是多项式加法和乘法的全部了。请注意，因为我们这里的操作都是基于通用型过程`add`和`mul`描述的，所以这个多项式包将自动地能够处理任何系数类型，只要它是这里的通用算术程序包能够处理的。如果我们还把[2.5.2]节所讨论的强制机制也包括进来，那么我们也就自动地有了能够处理不同系数类型的多项式操作的能力，例如

$$ [3x^2 + (2 + 3i)x + 7] \cdot \! \left[ x^4 + {2\over3} x^2 + (5 + 3i) \right]\!\!. $$

Because we installed the polynomial addition and multiplication procedures `add-poly` and `mul-poly` in the generic arithmetic system as the `add` and `mul` operations for type `polynomial`, our system is also automatically able to handle polynomial operations such as<br />
由于我们已经把多项式的求和、求乘积的过程`add-poly`和`mu1-poly`作为针对类型`polynomial`的操作，安装进通用算术系统的`add`和`mu1`操作里，这样得到的系统将能自动处理如下的多项式操作：

$$ \Big[(y + 1)x^2 + (y^2 + 1)x + (y - 1)\Big] \cdot \Big[(y - 2)x + (y^3 + 7)\Big]. $$

The reason is that when the system tries to combine coefficients, it will dispatch through `add` and `mul`. Since the coefficients are themselves polynomials (in ${y}$), these will be combined using `add-poly` and `mul-poly`. The result is a kind of ''data-directed recursion'' in which, for example, a call to `mul-poly` will result in recursive calls to `mul-poly` in order to multiply the coefficients. If the coefficients of the coefficients were themselves polynomials (as might be used to represent polynomials in three variables), the data direction would ensure that the system would follow through another level of recursive calls, and so on through as many levels as the structure of the data dictates.[^4]<br />
能够完成此事的原因是，当系统试图去归并系数时，它将通过add和mul进行分派。由于这时的系数本身也是多项式(y的多项式),它们将通过使用add-poly和mul-poly完成组合。这样就产生出一种“数据导向的递归”,举例来说，在这里，对mul-poly的调用中还会递归地调用mul-poly,以便去求系数的乘积。如果系数的系数仍然是多项式(在三个变元的多项式中可能出现这种情况),数据导向就会保证这一系统仍能进入另一层递归调用，并能这样根据被处理数据的结构进入任意深度的递归调用[^4]。

## Representing term lists(项表的表示)
Finally, we must confront the job of implementing a good representation for term lists. A term list is, in effect, a set of coefficients keyed by the order of the term. Hence, any of the methods for representing sets, as discussed in section [2.3.3], can be applied to this task. On the other hand, our procedures `add-terms` and `mul-terms` always access term lists sequentially from highest to lowest order. Thus, we will use some kind of ordered list representation.<br />
我们最后面临的工作，就是需要为项表实现一种很好的表示形式。从作用上看，一个项表就是一个以项的次数作为键值的系数集合，因此，任何能够用于有效表示集合的方法(见[2.3.3]节的讨论)都可以用于完成这一工作。但在另一方面，我们所用的过程`add-terms`和`mul-terms`都以顺序方式进行访问，按照从最高次项到最低次项的顺序，因此应该考虑采用某种有序表表示。

How should we structure the list that represents a term list? One consideration is the ''density'' of the polynomials we intend to manipulate. A polynomial is said to be dense if it has nonzero coefficients in terms of most orders. If it has many zero terms it is said to be sparse. For example,<br />
我们应该如何构造表示项表的表结构呢?有一个需要考虑的因素是可能需要操作的多项式的“密度”。一个多项式称为稠密的，如果它大部分次数的项都具有非0系数。如果一个多项式有许多系数为0的项，那么就称它是稀疏的。例如：

$$ A: \quad x^5 + 2x^4 + 3x^2 - 2x - 5 $$

is a dense polynomial, whereas<br />
是稠密的，而

$$ B: \quad x^{100} + 2x^2 + 1 $$

is sparse.<br />
是稀疏的。

The term lists of dense polynomials are most efficiently represented as lists of the coefficients. For example, A above would be nicely represented as `(1 2 0 3 -2 -5)`. The order of a term in this representation is the length of the sublist beginning with that term's coefficient, decremented by 1.[^5] This would be a terrible representation for a sparse polynomial such as B: There would be a giant list of zeros punctuated by a few lonely nonzero terms. A more reasonable representation of the term list of a sparse polynomial is as a list of the nonzero terms, where each term is a list containing the order of the term and the coefficient for that order. In such a scheme, polynomial B is efficiently represented as `((100 1) (2 2) (0 1))`. As most polynomial manipulations are performed on sparse polynomials, we will use this method. We will assume that term lists are represented as lists of terms, arranged from highest-order to lowest-order term. Once we have made this decision, implementing the selectors and constructors for terms and term lists is straightforward:[^6]<br />
对于稠密多项式而言，项表的最有效表示方式就是直接采用其系数的表。例如，上面的多项式A可以很好地表示为`(1 2 0 3 -2 -5)`。在这种表示中，一个项的次数也就是从这个项开始的子表的长度减1[^5]。对于像B那样的稀疏多项式，这种表示将变得十分可怕，因为它将是一个很大的几乎全都是0值的表，其中零零落落地点缀着几个非0项。对于稀疏多项式有一种更合理方式，那就是将它们表示为非0项的表，表中的每一项包含着多项式里的一个次数和对应于这个次数的系数。按照这种模式，多项式B可以有效地表示为`((100 1) (2 2) (0 1))`。由于被操作的大部分多项式运算都是稀疏多项式，我们采用后一种方式。现在假定项表被表示为项的表，按照从最高次到最低次的顺序安排。一旦我们做出了这一决定，为项表实现选择函数和构造函数就已经直截了当了[^6]。

```
(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))
(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))
(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
```

where `=zero?` is as defined in exercise [2.80]. (See also exercise [2.87] below.)<br />
这里的`=zero?`在练习[2.80]中定义(另见下面练习[2.87])。

Users of the polynomial package will create (tagged) polynomials by means of the procedure:<br />
多项式程序包的用户可以通过下面过程创建多项式：

```
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
```

<div id="Exercise2.87" markdown>

Exercise 2.87.  Install `=zero?` for polynomials in the generic arithmetic package. This will allow `adjoin-term` to work for polynomials with coefficients that are themselves polynomials.<br />
练习2.87  请在通用算术包中为多项式安装`=zero?`,这将使`adjoin-term`也能对系数本身也是多项式的多项式使用。

</div>

<div id="Exercise2.88" markdown>

Exercise 2.88.  Extend the polynomial system to include subtraction of polynomials. (Hint: You may find it helpful to define a generic negation operation.)<br />
练习2.88  请扩充多项式系统，加上多项式的减法。(提示：你可能发现定义一个通用的求负操作非常有用。)
</div>

<div id="Exercise2.89" markdown>

Exercise 2.89.  Define procedures that implement the term-list representation described above as appropriate for dense polynomials.<br />
练习2.89 请定义一些过程，实现上面讨论的适宜稠密多项式的项表表示。
</div>

<div id="Exercise2.90" markdown>

Exercise 2.90.  Suppose we want to have a polynomial system that is efficient for both sparse and dense polynomials. One way to do this is to allow both kinds of term-list representations in our system. The situation is analogous to the complex-number example of section [2.4], where we allowed both rectangular and polar representations. To do this we must distinguish different types of term lists and make the operations on term lists generic. Redesign the polynomial system to implement this generalization. This is a major effort, not a local change.<br />
练习2.90 假定我们希望有一个多项式系统，它应该对稠密多项式和稀疏多项式都非常有效。一种途径就是在我们的系统里同时允许两种表示形式。这时的情况类似于[2.4]节复数的例子，那里同时允许采用直角坐标表示和极坐标表示。为了完成这一工作，我们必须区分不同的项表类型，并将针对项表的操作通用化。请重新设计这个多项式系统，实现这种推广。这将是一项需要付出很多努力的工作，而不是一个局部修改。

</div>

<div id="Exercise2.91" markdown>

Exercise 2.91.  A univariate polynomial can be divided by another one to produce a polynomial quotient and a polynomial remainder. For example,<br />
练习2.91  一个单变元多项式可以除以另一个多项式，产生出一个商式和一个余式。例如：

$$ {x^5 - 1 \over x^2 - 1} = x^3 + x, \hbox{  remainder  } x - 1. $$

Division can be performed via long division. That is, divide the highest-order term of the dividend by the highest-order term of the divisor. The result is the first term of the quotient. Next, multiply the result by the divisor, subtract that from the dividend, and produce the rest of the answer by recursively dividing the difference by the divisor. Stop when the order of the divisor exceeds the order of the dividend and declare the dividend to be the remainder. Also, if the dividend ever becomes zero, return zero as both quotient and remainder.<br />
除法可以通过长除完成。也就是说，用被除式的最高次项除以除式的最高次项，得到商式的第一项；而后用这个结果乘以除式，并从被除式中减去这个乘积。剩下的工作就是用减后得到的差作为新的被除式，以便产生出随后的结果。当除式的次数超过被除式的次数时结束，将此时的被除式作为余式。还有，如果被除式就是0,那么就返回0作为商和余式。

We can design a `div-poly` procedure on the model of `add-poly` and `mul-poly`. The procedure checks to see if the two polys have the same variable. If so, `div-poly` strips off the variable and passes the problem to `div-terms`, which performs the division operation on term lists. `Div-poly` finally reattaches the variable to the result supplied by `div-terms`. It is convenient to design `div-terms` to compute both the quotient and the remainder of a division. `Div-terms` can take two term lists as arguments and return a list of the quotient term list and the remainder term list.<br />
我们可以基于`add-poly`和`mul-poly`的模型，设计出一个除法过程`div-poly`。这一过程首先检查两个多项式是否具有相同的变元，如果是的话就剥去这一变元，将问题送给过程`div-terms`,它执行项表上的除法运算。`div-poly`最后将变元重新附加到`div-terms`返回的结果上。将`div-terms`设计为同时计算出除法的商式和余式是比较方便的。`div-terms`可以以两个表为参数，返回一个商式的表和一个余式的表。

Complete the following definition of `div-terms` by filling in the missing expressions. Use this to implement `div-poly`, which takes two polys as arguments and returns a list of the quotient and remainder polys.<br />
请完成下面`div-terms`的定义，填充其中空缺的表达式，并基于它实现`div-poly`。该过程应该以两个多项式为参数，返回一个包含商和余式多项式的表。

```
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     <compute rest of result recursively>
                     ))
                <form complete result>
                ))))))
```
</div>

## Hierarchies of types in symbolic algebra(符号代数中类型的层次结构)
Our polynomial system illustrates how objects of one type (polynomials) may in fact be complex objects that have objects of many different types as parts. This poses no real difficulty in defining generic operations. We need only install appropriate generic operations for performing the necessary manipulations of the parts of the compound types. In fact, we saw that polynomials form a kind of ''recursive data abstraction,'' in that parts of a polynomial may themselves be polynomials. Our generic operations and our data-directed programming style can handle this complication without much trouble.<br />
我们的多项式系统显示出，一种类型(多项式)的对象事实上可以是一个复杂的对象，又以许多不同类型的对象作为其组成部分。这种情况并不会给定义通用型操作增加任何实际困难。我们需要做的就是针对这种复合对象的各个部分的操作，并安装好适当的通用型过程。事实上，我们可以看到多项式形成了一类“递归数据抽象”,因为多项式的某些部分本身也可能是多项式。我们的通用型操作和数据导向的程序设计风格完全可以处理这种复杂性，这里并没有多少困难。

On the other hand, polynomial algebra is a system for which the data types cannot be naturally arranged in a tower. For instance, it is possible to have polynomials in ${x}$ whose coefficients are polynomials in ${y}$. It is also possible to have polynomials in ${y}$ whose coefficients are polynomials in ${x}$. Neither of these types is ''above'' the other in any natural way, yet it is often necessary to add together elements from each set. There are several ways to do this. One possibility is to convert one polynomial to the type of the other by expanding and rearranging terms so that both polynomials have the same principal variable. One can impose a towerlike structure on this by ordering the variables and thus always converting any polynomial to a ''canonical form'' with the highest-priority variable dominant and the lower-priority variables buried in the coefficients. This strategy works fairly well, except that the conversion may expand a polynomial unnecessarily, making it hard to read and perhaps less efficient to work with. The tower strategy is certainly not natural for this domain or for any domain where the user can invent new types dynamically using old types in various combining forms, such as trigonometric functions, power series, and integrals.<br />
但在另一方面，多项式代数也是这样的一个系统，其中的数据类型不能自然地安排到一个类型塔里。例如，在这里可能有 ${x}$ 的多项式，其系数是 ${y}$ 的多项式；也完全可能有 ${y}$ 的多项式，其系数是 ${x}$ 的多项式。这些类型中没有哪个类型自然地位于另一类型的“上面”,然而我们却常常需要去求不同集合的成员之和。有几种方式可以完成这件事情。一个可能性就是将一个多项式变换到另一个多项式的类型，这可以通过展开并重新安排多项式里的项，使两个多项式都具有同样的主变元。也可以通过对变元的排序，在其中强行加入一个类型塔结构，并且永远把所有的多项式都变换到一种“规范形式”,使具有最高优先级的变元成为主变元，将优先级较低的变元藏在系数里面。这种策略工作的相当好，但是，在做这种变换时，有可能毫无必要地扩大了多项式，使它更难读，也可能操作起来的效率更低。塔型策略在这个领域中确实不大自然，对于另一些领域也是一样，如果在那里用户可以动态地通过已有类型的各种组合形式引进新类型。这样的例子如三角函数、幂级数和积分。

It should not be surprising that controlling coercion is a serious problem in the design of large-scale algebraic-manipulation systems. Much of the complexity of such systems is concerned with relationships among diverse types. Indeed, it is fair to say that we do not yet completely understand coercion. In fact, we do not yet completely understand the concept of a data type. Nevertheless, what we know provides us with powerful structuring and modularity principles to support the design of large systems.<br />
如果说在设计大型代数演算系统时，对于强制的控制会变成一个很严重的问题，那完全不应该感到奇怪。这种系统里的大部分复杂性都牵涉到多个类型之间的关系。确实，公平地说，我们到现在还没有完全理解强制。事实上，我们还没有完全理解类型的概念。但无论如何，已知的东西已经为我们提供了支持大型系统设计的强有力的结构化和模块化原理。

<div id="Exercise2.92">

Exercise 2.92.  By imposing an ordering on variables, extend the polynomial package so that addition and multiplication of polynomials works for polynomials in different variables. (This is not easy!)<br />
练习2.92  通过加入强制性的变量序扩充多项式程序包，使多项式的加法和乘法能对具有不同变量的多项式进行。(这绝不简单!)

</div>

## Extended exercise: Rational functions(扩充练习：有理函数)
We can extend our generic arithmetic system to include rational functions. These are ''fractions'' whose numerator and denominator are polynomials, such as<br />
我们可以扩充前面已经做出的通用算术系统，将有理函数也包含进来。有理函数也就是“分式”,其分子和分母都是多项式，例如：

$$ {x + 1 \over x^3 - 1}\,. $$

The system should be able to add, subtract, multiply, and divide rational functions, and to perform such computations as<br />
这个系统应该能做有理函数的加减乘除，并可以完成下面的计算：

$$ {x + 1 \over x^3 - 1} + {x \over x^2 - 1} = 
	{x^3 + 2x^2 + 3x + 1 \over x^4 + x^3 - x - 1}\,. $$

(Here the sum has been simplified by removing common factors. Ordinary ''cross multiplication'' would have produced a fourth-degree polynomial over a fifth-degree polynomial.)<br />
(这里的和已经经过了简化，删除了公因子。常规的“交叉乘法”得到的将是一个4次多项式的分子和5次多项式的分母。)

If we modify our rational-arithmetic package so that it uses generic operations, then it will do what we want, except for the problem of reducing fractions to lowest terms.<br />
修改前面的有理数程序包，使它能使用通用型操作，就能完成我们希望做的事情，除了无法将分式化简到最简形式之外。

<div id="Exercise2.93">

Exercise 2.93.  Modify the rational-arithmetic package to use generic operations, but change `make-rat` so that it does not attempt to reduce fractions to lowest terms. Test your system by calling `make-rational` on two polynomials to produce a rational function<br />
练习2.93 请修改有理数算术包，采用通用型操作，但在其中改写`make-rat`,使它并不企图去将分式化简到最简形式。对下面两个多项式调用`make-rational`做出一个有理函数，以便检查你的系统：

```
(define p1 (make-polynomial 'x '((2 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 1))))
(define rf (make-rational p2 p1))
```

Now add `rf` to itself, using `add`. You will observe that this addition procedure does not reduce fractions to lowest terms.<br />
现在用`add`将`rf`与它自己相加。你会看到这个加法过程不能将分式化简到最简形式。

We can reduce polynomial fractions to lowest terms using the same idea we used with integers: modifying `make-rat` to divide both the numerator and the denominator by their greatest common divisor. The notion of ''greatest common divisor'' makes sense for polynomials. In fact, we can compute the GCD of two polynomials using essentially the same Euclid's Algorithm that works for integers.[^7] The integer version is<br />
我们可以用与前面针对整数工作时的同样想法，将分子和分母都是多项式的分式简化到最简形式：修改`make-rat`,将分子和分母都除以它们的最大公因子。“最大公因子”的概念对于多项式也是有意义的。事实上，我们也可以用与整数的欧几里得算法本质上相同的算法求出两个多项式的GCD(最大公因子)[^7]。对于整数的算法是：

```
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
```

Using this, we could make the obvious modification to define a GCD operation that works on term lists:<br />
利用它，再做一点非常明显的修改，就可以定义出一个对项表工作的GCD操作：

```
(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
```

where remainder-terms picks out the remainder component of the list returned by the term-list division operation div-terms that was implemented in exercise [2.91].<br />
其中的remainder-terms提取出由项表除法操作div-terms返回的表里的余式成分，该操作在练习[2.91]中实现。
</div>

<div id="Exercise2.94" markdown>

Exercise 2.94.  Using `div-terms`, implement the procedure `remainder-terms` and use this to define `gcd-terms` as above. Now write a procedure `gcd-poly` that computes the polynomial GCD of two polys. (The procedure should signal an error if the two polys are not in the same variable.) Install in the system a generic operation `greatest-common-divisor` that reduces to `gcd-poly` for polynomials and to ordinary `gcd` for ordinary numbers. As a test, try<br />
练习2.94  利用`div-terms`实现过程`remainder-terms`,并用它定义出上面的`gcd-terms`。现在写出一个过程`gcd-poly`,它能计算出两个多项式的多项式GCD(如果两个多项式的变元不同，这个过程应该报告错误)。在系统中安装通用型操作`greatest-common-divisor`,使得遇到多项式时，它能归约到`gcd-poly`,对于常规的数能归约到常规的`gcd`。作为试验，请做：

```
(define p1 (make-polynomial 'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
```

and check your result by hand.<br />
并用手工检查得到的结果。

</div>

<div id="Exercise2.95" markdown>

Exercise 2.95.  Define ${P_1}$, ${P_2}$, and ${P_3}$ to be the polynomials<br />
练习2.95请定义多项式 ${P_1}$、${P_2}$ 和 ${P_3}$:

$$ \eqalign{
	P_1 	&: \quad x^2 - 2x + 1, \cr
	P_2 	&: \quad 11x^2 + 7, \cr
	P_3 	&: \quad 13x + 5. \cr
} $$

Now define ${Q_1}$ to be the product of ${P_1}$ and ${P_2}$ and ${Q_2}$ to be the product of ${P_1}$ and ${P_3}$, and use `greatest-common-divisor` (exercise [2.94]) to compute the GCD of ${Q_1}$ and ${Q_2}$. Note that the answer is not the same as ${P_1}$. This example introduces noninteger operations into the computation, causing difficulties with the GCD algorithm.[^8] To understand what is happening, try tracing `gcd-terms` while computing the GCD or try performing the division by hand.<br />
现在定义 ${Q_1}$ 为 ${P_1}$ 和 ${P_2}$ 的乘积，定义 ${Q_2}$ 为 ${P_1}$ 和 ${P_3}$ 的乘积，而后用`greatest-common-divisor`(练习[2.94])求出 ${Q_1}$ 和 ${Q_2}$ 的GCD。请注意得到的回答与 ${P_1}$ 并不一样。这个例子将非整数操作引进了计算过程，从而引起了GCD算法的困难'”。要理解这里发生了什么，请试着手工追踪`gcd-terms`在计算GCD或者做除法时的情况。

We can solve the problem exhibited in exercise [2.95] if we use the following modification of the GCD algorithm (which really works only in the case of polynomials with integer coefficients). Before performing any polynomial division in the GCD computation, we multiply the dividend by an integer constant factor, chosen to guarantee that no fractions will arise during the division process. Our answer will thus differ from the actual GCD by an integer constant factor, but this does not matter in the case of reducing rational functions to lowest terms; the GCD will be used to divide both the numerator and denominator, so the integer constant factor will cancel out.<br />
如果我们对于GCD算法采用下面的修改，就可以解决练习[2.95]揭示出的问题(这只能对整数系数的多项式使用)。在GCD计算中执行任何多项式除法之前，我们先将被除式乘以一个整数的常数因子，选择的方式是保证在除的过程中不出现分数。这样得到的回答将比实际的GCD多出一个整的常数因子，但它不会在将有理函数化简到最简形式的过程中造成任何问题。由于将用这个GCD去除分子和分母，所以这个常数因子会被消除掉。

More precisely, if ${P}$ and ${Q}$ are polynomials, let ${O_1}$ be the order of ${P}$ (i.e., the order of the largest term of ${P}$ and let ${O_2}$ be the order of ${Q}$. Let ${c}$ be the leading coefficient of ${Q}$. Then it can be shown that, if we multiply ${P}$ by the integerizing factor ${c^{1 + O_1 - O_2}}$, the resulting polynomial can be divided by ${Q}$ by using the div-terms algorithm without introducing any fractions. The operation of multiplying the dividend by this constant and then dividing is sometimes called the pseudodivision of P by ${Q}$. The remainder of the division is called the pseudoremainder.<br />
说得更精确些，如果 ${P}$ 和 ${Q}$ 都是多项式，令 ${O_1}$ 是 ${P}$ 的次数( ${P}$ 的最高次项的次数),令 ${O_2}$ 是 ${Q}$ 的次数，令 ${c}$ 是 ${Q}$ 的首项系数。可以证明，如果我们给 ${P}$ 乘上一个整数化因子 ${c^{1 + O_1 - O_2}}$,得到的多项式用`div-terms`算法除以 ${Q}$ 将不会引进任何分数。将被除式乘上这样的常数后除以除式，这种操作在某些地方称为 ${P}$ 对于 ${Q}$ 的伪除，这样除后得到的余式也被称为伪余。
</div>

<div id="Exercise2.96" markdown>

Exercise 2.96.  a. Implement the procedure `pseudoremainder-terms`, which is just like `remainder-terms` except that it multiplies the dividend by the integerizing factor described above before calling `div-terms`. Modify `gcd-terms` to use `pseudoremainder-terms`, and verify that `greatest-common-divisor` now produces an answer with integer coefficients on the example in exercise [2.95].<br />
练习2.96
a .请实现过程`pseudoremainder-terms`,它就像是`remainder-terms`,但是像上面所描述的那样，在调用`div-terms`之前，先将被除式乘了整数化因子。请修改`gcd-terms`使之能使用`pseudoremainder-terms`,并检验现在`greatest-common-divisor`能否对练习[2.95]的例子产生出一个整系数的答案。

b.  The GCD now has integer coefficients, but they are larger than those of ${P_1}$. Modify `gcd-terms` so that it removes common factors from the coefficients of the answer by dividing all the coefficients by their (integer) greatest common divisor.<br />
b. 现在的GCD保证能得到整系数，但它们将比 ${P_1}$ 的系数大，请修改`gcd-terms`使它能从答案的所有系数中删除公因子，方法是将这些系数都除以它们的(整数)最大公约数。

Thus, here is how to reduce a rational function to lowest terms:<br />
至此我们已经弄清了如何将一个有理函数化简到最简形式：

- Compute the GCD of the numerator and denominator, using the version of `gcd-terms` from exercise [2.96].<br />
用取自练习[2.96]的`gcd-terms`版本计算出分子和分母的GCD;

- When you obtain the GCD, multiply both numerator and denominator by the same integerizing factor before dividing through by the GCD, so that division by the GCD will not introduce any noninteger coefficients. As the factor you can use the leading coefficient of the GCD raised to the power ${1 + O_1 - O_2}$, where ${O_2}$ is the order of the GCD and ${O_1}$ is the maximum of the orders of the numerator and denominator. This will ensure that dividing the numerator and denominator by the GCD will not introduce any fractions.<br />
在你得到了这个GCD后，在用GCD去除分子和分母之前，先将它们都乘以同一个整数化因子，以使除以这个GCD不会引进任何非整数系数。作为这个因子，你可以使用得到的GCD的首项系数的 ${1 + O_1 - O_2}$ 次幂。其中 ${O_2}$ 是这个GCD的次数，${O_1}$ 是分子与分母的次数中大的那一个。这将保证用这个GCD去除分子和分母不会引进任何分数。

- The result of this operation will be a numerator and denominator with integer coefficients. The coefficients will normally be very large because of all of the integerizing factors, so the last step is to remove the redundant factors by computing the (integer) greatest common divisor of all the coefficients of the numerator and the denominator and dividing through by this factor.<br />
这一操作得到的结果将是具有整系数的分子和分母。它们的系数通常会由于整数化因子而变得非常大。所以最后一步是去除这个多余的因子，为此需要首先计算出分子和分母中所有系数的(整数)最大公约数，而后除去这个公约数。
</div>

<div id="Exercise2.97" markdown>

Exercise 2.97.  a. Implement this algorithm as a procedure `reduce-terms` that takes two term lists `n` and `d` as arguments and returns a list `nn`, `dd`, which are `n` and `d` reduced to lowest terms via the algorithm given above. Also write a procedure `reduce-poly`, analogous to `add-poly`, that checks to see if the two polys have the same variable. If so, `reduce-poly` strips off the variable and passes the problem to `reduce-terms`, then reattaches the variable to the two term lists supplied by `reduce-terms`.<br />
练习2.97
a. 请将这一算法实现为过程`reduce-terms`,它以两个项表`n`和`d`为参数，返回一个包含`nn`和`dd`的表，它们分别是由`n`和`d`通过上面描述的算法简化而得到的最简形式。另请写出一个与`add-poly`类似的过程`peduce-poly`,它检查两个多项式是否具有同样变元。如果是的话，`reduce-poly`就剥去其中变元，并将问题交给`reduce-terms`,最后为`reduce-terms`返回的表里的两个项表重新附加上变元。

b. Define a procedure analogous to `reduce-terms` that does what the original `make-rat` did for integers:<br />
b. 请定义一个类似于`reduce-terms`的过程，它完成的工作就像是`make-rat`对整数做的事情：

```
(define (reduce-integers n d)
  (let ((g (gcd n d)))
    (list (/ n g) (/ d g))))
```

and define `reduce` as a generic operation that calls `apply-generic` to dispatch to either `reduce-poly` (for `polynomial` arguments) or `reduce-integers` (for `scheme-number` arguments). You can now easily make the rational-arithmetic package reduce fractions to lowest terms by having `make-rat` call `reduce` before combining the given numerator and denominator to form a rational number. The system now handles rational expressions in either integers or polynomials. To test your program, try the example at the beginning of this extended exercise:<br />
再将`reduce`定义为一个通用型操作，它调用`apply-generic`完成到`reduce-poly`(对于`polynomial`参数)或者到`reduce-integers`(对`scheme-number`参数)的分派。你可以很容易让有理数算术包将分式简化到最简形式，采用的方式就是让`make-rat`在组合给定分子和分母，做出有理数之前也调用`reduce`。这一系统现在就能处理整数或者多项式的有理表达式了。为测试你的程序，请首先试验下面的扩充练习：

```
(define p1 (make-polynomial 'x '((1 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 -1))))
(define p3 (make-polynomial 'x '((1 1))))
(define p4 (make-polynomial 'x '((2 1)(0 -1))))

(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))

(add rf1 rf2)
```

See if you get the correct answer, correctly reduced to lowest terms.<br />
看看能否得到正确结果，结果是否正确地化简为最简形式。

The GCD computation is at the heart of any system that does operations on rational functions. The algorithm used above, although mathematically straightforward, is extremely slow. The slowness is due partly to the large number of division operations and partly to the enormous size of the intermediate coefficients generated by the pseudodivisions. One of the active areas in the development of algebraic-manipulation systems is the design of better algorithms for computing polynomial GCDs.[^9]<br />
GCD计算是所有需要完成有理函数操作的系统的核心。上面所使用的算法虽然在数学上直截了当，但却异常低效。低效的部分原因在于大量的除法操作，部分在于由伪除产生的巨大的中间系数。在开发代数演算系统的领域中，一个很活跃问题就是设计计算多项式GCD的更好算法[^9],
</div>

[^1]:
    On the other hand, we will allow polynomials whose coefficients are themselves polynomials in other variables. This will give us essentially the same representational power as a full multivariate system, although it does lead to coercion problems, as discussed below.<br />
    在另一方面，我们将允许多项式的系数本身是其他变元的多项式。这就给了我们与完全的多变量系统一样充分的表达能力，虽然会引起一些强制问题。详情见下面的讨论。

[^2]:
    For univariate polynomials, giving the value of a polynomial at a given set of points can be a particularly good representation. This makes polynomial arithmetic extremely simple. To obtain, for example, the sum of two polynomials represented in this way, we need only add the values of the polynomials at corresponding points. To transform back to a more familiar representation, we can use the Lagrange interpolation formula, which shows how to recover the coefficients of a polynomial of degree n given the values of the polynomial at ${n + 1}$ points.<br />
    对于单变元多项式而言，给出一个多项式在一集点的值可能成为一种特别好的表示方式。这将使多项式算术变得特别简单。例如，要得到两个以这种方式表示的多项式之和，我们只需加起这两个多项式在对应点的值。要将它们变换到我们更热悉的形式，可以利用拉格朗日插值公式，它说明了如何从多项式在 ${n + 1}$ 个点的给定值构造出一个n阶多项式的各个系数。

[^3]:
    This operation is very much like the ordered `union-set` operation we developed in exercise  [2.62]. In fact, if we think of the terms of the polynomial as a set ordered according to the power of the indeterminate, then the program that produces the term list for a sum is almost identical to `union-set`.<br />
    这一运算很像我们在练习[2.62]中开发的有序`union-set`运算，事实上，如果我们将多项式看成根据未定元的次数排序的集合，那么为求和产生项表的程序儿乎就等同于`union-set`了。


[^4]:
    To make this work completely smoothly, we should also add to our generic arithmetic system the ability to coerce a ''number'' to a polynomial by regarding it as a polynomial of degree zero whose coefficient is the number. This is necessary if we are going to perform operations such as<br />
    为了使这些工作得更加平滑，我们还需在这个通用算术系统中加入将“数”强制到多项式的能力。这时把数看成是次数为0而系数就是这个数的多项式。如果要处理下面的多项式运算，就需要这种功能：

    $$ [x^2 + (y + 1)x + 5] + [x^2 + 2x + 1], $$

    which requires adding the coefficient y + 1 to the coefficient 2<br />
    这其中需要求出系数y+1和系数2之和。

[^5]:
    In these polynomial examples, we assume that we have implemented the generic arithmetic system using the type mechanism suggested in exercise [2.78]. Thus, coefficients that are ordinary numbers will be represented as the numbers themselves rather than as pairs whose car is the symbol scheme-number.<br />
    在这些多项式的例子里，我们都假定使用的是练习[2.78]所提出的通用算术系统。这样，常规数值的系数将直接用数值本身表示，而不是表示为一个car为符号scheme-number的对偶。

[^6]:
    Although we are assuming that term lists are ordered, we have implemented `adjoin-term` to simply `cons` the new term onto the existing term list. We can get away with this so long as we guarantee that the procedures (such as `add-terms`) that use `adjoin-term` always call it with a higher-order term than appears in the list. If we did not want to make such a guarantee, we could have implemented `adjoin-term` to be similar to the `adjoin-set` constructor for the ordered-list representation of sets (exercise [2.61]).<br />
    虽然我们假定项表是排序的，这里还是将`adjoin-term`简单地实现为用`cons`在现存项表前加一个新项。只要能保证使用`adjoin-term`的过程(如`add-terms`)总用比表中的项次数更高的项调用它，我们就不必担心会出问题。如果不希望事先有这种保证，那么就可以采用类似于集合的有序表表示中实现构造函数`adjoin-set`的方式(练习[2.61])实现`adjoin-term`.

[^7]:
    The fact that Euclid's Algorithm works for polynomials is formalized in algebra by saying that polynomials form a kind of algebraic domain called a Euclidean ring. A Euclidean ring is a domain that admits addition, subtraction, and commutative multiplication, together with a way of assigning to each element ${x}$ of the ring a positive integer ''measure'' ${m(x)}$ with the properties that ${m(xy) \ge m(x)}$ for any nonzero ${x}$ and ${y}$ and that, given any ${x}$ and ${y}$, there exists a ${q}$ such that ${y = qx + r}$ and either ${r = 0}$ or ${m(r) < m(x)}$. From an abstract point of view, this is what is needed to prove that Euclid's Algorithm works. For the domain of integers, the measure m of an integer is the absolute value of the integer itself. For the domain of polynomials, the measure of a polynomial is its degree.<br />
    按照代数的说法，欧几里得算法对于多项式也可以使用的事实说明多项式构成了一种代数论域，称为欧几里得环。一个欧几里得环是一种论域，它允许加、减和可交换乘，再加上一种方式为环中每个元素赋以一个正整数的“度量” ${m(x)}$,其性质是，对任何非0的 ${x}$ 和 ${y}$ 都有 ${m(xy) \ge m(x)}$,而且对于任何给定的和 ${y}$,存在一个使得 ${y = qx + r}$,这里有 ${r = 0}$ 或者 ${m(r) < m(x)}$。从一种抽象的观点看，这些也就是证明欧儿里得算法能够使用所需要的所有性质。对干整数论域而言，一个整数的度量m就是这个整数的绝对值。对多项式论域，这一度量就是多项式的次数。

[^8]:
    In an implementation like MIT Scheme, this produces a polynomial that is indeed a divisor of ${Q_1}$ and ${Q_2}$, but with rational coefficients. In many other Scheme systems, in which division of integers can produce limited-precision decimal numbers, we may fail to get a valid divisor.<br />
    在类似MIT Scheme的实现中，这将产生一个多项式，它确实是 ${Q_1}$ 和 ${Q_2}$ 的因子，但却有着有理数系数。许多其他Scheme系统中的整数除法可以产生有限精度的十进制数，这时可能就无法得到合法的因子了。

[^9]:
    One extremely efficient and elegant method for computing polynomial GCDs was discovered by Richard Zippel (1979). The method is a probabilistic algorithm, as is the fast test for primality that we discussed in chapter 1. Zippel's book (1993) describes this method, together with other ways to compute polynomial GCDs.<br />
    一个特别高效而优美的计算多项式GCD的方法由Richard Zippel发明(1979)。这是一个概率算法，就像我们在第1章讨论过的素数快速检查算法。Zippel的书(1993)里讨论了这个算法，还介绍了计算多项式GCD的其他一些方法。


[2.3.2]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_3/2.3.2/

[2.5.1]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.1/

[2.5.2]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.2/

[2.62]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_3/2.3.3/#Exercise2.62

[2.61]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_3/2.3.3/#Exercise2.61

[2.78]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.1/#Exercise2.78

[2.80]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.1/#Exercise2.80

[2.87]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.3/#Exercise2.87

[2.4]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_4/

[2.91]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.3/#Exercise2.91

[2.94]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.3/#Exercise2.94

[2.95]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.3/#Exercise2.95

[2.96]: {{ config.extra.homepage_sicp }}/chapter_2/chapter_2_5/2.5.3/#Exercise2.96


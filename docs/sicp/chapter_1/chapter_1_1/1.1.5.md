---
comments: true
---

# 1.1.5  过程应用的代换模型

为了求值一个组合式(其运算符是一个复合过程的名字),解释器的工作方式将完全按照[1.1.3]节中所描述的那样，采用与以运算符名为基本过程的组合式一样的计算过程。也就是说解释器将对组合式的各个元素求值，而后将得到的那个过程(也就是该组合式里运算符的值)应用于那些实际参数(即组合式里那些运算对象的值)。

我们可以假定，把基本运算符应用于实参的机制已经在解释器里做好了。对于复合过程，过程应用的计算过程是：

将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。

为了说明这种计算过程，让我们看看下面组合式的求值：

```
(f 5)
```

其中的 **f** 是[1.1.4]节定义的那个过程。我们首先提取出 **f** 的体：

```
(sum-of-squares (+ a 1) (* a 2))
```

而后用实际参数5代换其中的形式参数:

```
(sum-of-squares (+ 5 1) (* 5 2))
```

这样，问题就被归约为对另一个组合式的求值，其中有两个运算对象，有关的运算符是 **sum-of-squares**。求值这一组合式牵涉到三个子问题：我们必须对其中的运算符求值，以便得到应该去应用的那个过程；还需要求值两个运算对象，以得到过程的实际参数。这里的 **(+ 5 1)** 产生出 **6**, **(*  5  2)** 产生出 **10**, 因此我们就需要将**sum-of-squares** 过程用于 **6** 和 **10**。用这两个值代换 **sum-of-squares** 体中的形式参数 **x** 和 **y**, 表达式被归约为：

```
(+ (square 6) (square 10))
```

使用 **square** 的定义又可以将它归约为：

```
(+ (* 6 6) (* 10 10))
```

通过乘法又能将它进一步归约为：

```
(+ 36 100)
```

最后得到:

```
136
```

上面描述的这种计算过程称为过程应用的 **代换模型**，在考虑本章至今所定义的过程时，我们可以将它看作确定过程应用的“意义”的一种模型。但这里还需要强调两点：

- 代换的作用只是为了帮助我们领会过程调用中的情况，而不是对解释器实际工作方式的具体描述。通常的解释器都不采用直接操作过程的正文，用值去代换形式参数的方式去完成对过程调用的求值。在实际中，它们一般采用提供形式参数的局部环境的方式，产生“代换”的效果。我们将在第3章和第4章考察一个解释器的细节实现，在那里更完整地讨论这一问题。

- 随着本书讨论的进展，我们将给出有关解释器如何工作的一系列模型， 一个比一个更精细，并最终在第5章给出一个完整的解释器和一个编译器。这里的代换模型只是这些模型中的第一个——作为形式化地考虑这种求值过程的起点。一般来说，在模拟科学研究或者工程中的现象时，我们总是从最简单的不完全的模型开始。随着更细致地检查所考虑的问题，这些简单模型也会变得越来越不合适，从而必须用进一步精化的模型取代。代换模型也不例外。特别地，在第3章中，我们将要讨论将过程用于“变化的数据”的问题，那时就会看到替换模型完全不行了，必须用更复杂的过程应用模型来代替它

## 应用序和正则序

按照[1.1.3]节给出的有关求值的描述，解释器首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。然而，这并不是执行求值的惟一可能方式。另一种求值模型是先不求出运算对象的值，直到实际需要它们的值时再去做。采用这种求值方式，我们就应该首先用运算对象表达式去代换形式参数，直至得到一个只包含基本运算符的表达式，然后再去执行求值。如果我们采用这一方式，对下面表达式的求值：

```
(f 5)
```

将按照下面的序列逐步展开：

```
(sum-of-squares (+ 5 1) (* 5 2))

(+    (square (+ 5 1))      (square (* 5 2))  )

(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
```

而后是下面归约：

```
(+         (* 6 6)             (* 10 10))

(+           36                   100)

                    136
```

这给出了与前面求值模型同样的结果，但其中的计算过程却是不一样的。特别地，在对下面表达式的归约中，对于 **(+ 5 1)** 和 **(* 5 2)** 的求值各做了两次：

```
(* x x)
```

其中的 **x** 分别被代换为 **(+ 5 1)** 和 **(* 5 2)**.

这种“完全展开而后归约”的求值模型称为 **正则序求值**，与之对应的是现在解释器里实际使用的“先求值参数而后应用”的方式，它称为 **应用序求值**。可以证明，对那些可以通过替换去模拟，并能产生出合法值的过程应用(包括本书前两章中的所有过程),正则序和应用序求值将产生出同样的值(参见练习[1.5]中一个“非法”值的例子，其中正则序和应用序将给出不同的结果)。

Lisp采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值(例如上面的 **(+ 5 1)** 和 **(* 5 2)** 的情况),从而可以提高一些效率。更重要的是，在超出了可以采用替换方式模拟的过程范围之后，正则序的处理将变得更复杂得多。而在另一些方面，正则序也可以成为特别有价值的工具，我们将在第3章和第4章研究它的某些内在性质。

  [1.1.3]: 1.1.3.md
  [1.1.4]: 1.1.4.md